
@online{popov_type_2021,
	title = {Type variance in {PHP}},
	url = {https://www.npopov.com/2021/11/08/Type-variance-in-PHP.html},
	type = {Blog},
	author = {Popov, Nikita},
	urldate = {2022-05-30},
	date = {2021-11-08},
	file = {Type variance in PHP:/home/girgias/Zotero/storage/RKFBIBHT/Type-variance-in-PHP.html:text/html},
}

@article{liskov_behavioral_1994,
	title = {A behavioral notion of subtyping},
	volume = {16},
	issn = {0164-0925},
	url = {https://doi.org/10.1145/197320.197383},
	doi = {10.1145/197320.197383},
	abstract = {The use of hierarchy is an important component of object-oriented design. Hierarchy allows the use of type families, in which higher level supertypes capture the behavior that all of their subtypes have in common. For this methodology to be effective, it is necessary to have a clear understanding of how subtypes and supertypes are related. This paper takes the position that the relationship should ensure that any property proved about supertype objects also holds for its subtype objects. It presents two ways of defining the subtype relation, each of which meets this criterion, and each of which is easy for programmers to use. The subtype relation is based on the specifications of the sub- and supertypes; the paper presents a way of specifying types that makes it convenient to define the subtype relation. The paper also discusses the ramifications of this notion of subtyping on the design of type families.},
	pages = {1811--1841},
	number = {6},
	journaltitle = {{ACM} Transactions on Programming Languages and Systems},
	shortjournal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Liskov, Barbara H. and Wing, Jeannette M.},
	urldate = {2022-10-10},
	date = {1994-11-01},
	keywords = {formal specifications, Larch, subtyping},
	file = {Full Text PDF:/home/girgias/Zotero/storage/29DPWR2F/Liskov and Wing - 1994 - A behavioral notion of subtyping.pdf:application/pdf},
}

@online{seemann_liskov_2021,
	title = {The Liskov Substitution Principle as a profunctor},
	url = {https://blog.ploeh.dk/2021/12/06/the-liskov-substitution-principle-as-a-profunctor/},
	titleaddon = {ploeh blog danish software design},
	type = {Blog},
	author = {Seemann, Mark},
	urldate = {2022-10-10},
	date = {2021-12-06},
	file = {The Liskov Substitution Principle as a profunctor:/home/girgias/Zotero/storage/ETFQ32GF/the-liskov-substitution-principle-as-a-profunctor.html:text/html},
}

@online{banyard_php_2020,
	title = {{PHP} {RFC}: Saner numeric strings},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/saner-numeric-strings},
	shorttitle = {Saner numeric strings},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2022-10-10},
	date = {2020-06-28},
	keywords = {{PHP} {RFC}},
}

@online{banyard_php_2022,
	title = {{PHP} {RFC}: Path to Saner Increment/Decrement operators},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/saner-inc-dec-operators},
	shorttitle = {Path to Saner Increment/Decrement operators},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2023-02-15},
	date = {2022-11-21},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:saner-inc-dec-operators:/home/girgias/Zotero/storage/QWH4ZDNT/saner-inc-dec-operators.html:text/html},
}

@online{banyard_php_2023,
	title = {{PHP} {RFC}: Saner array\_(sum{\textbar}product)()},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/saner-array-sum-product},
	shorttitle = {Saner array\_(sum{\textbar}product)()},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2023-02-15},
	date = {2023-01-14},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:saner-array-sum-product:/home/girgias/Zotero/storage/Q3KHXJQQ/saner-array-sum-product.html:text/html},
}

@online{banyard_php_2020-1,
	title = {{PHP} {RFC}: Locale-independent float to string cast},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/locale_independent_float_to_string},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter and Kocsis, Máté},
	urldate = {2023-02-19},
	date = {2020-03-11},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:locale_independent_float_to_string:/home/girgias/Zotero/storage/ZUSHA8UR/locale_independent_float_to_string.html:text/html},
}

@online{banyard_php_2023-1,
	title = {{PHP} {RFC}: Define proper semantics for range() function},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/proper-range-semantics},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2023-05-11},
	date = {2023-03-13},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:proper-range-semantics:/home/girgias/Zotero/storage/NM9HRCGT/proper-range-semantics.html:text/html},
}

@online{duffy_error_2016,
	title = {The Error Model},
	url = {https://joeduffyblog.com/2016/02/07/the-error-model/},
	titleaddon = {Joe Duffy's Blog},
	author = {Duffy, Joe},
	urldate = {2023-05-11},
	date = {2016-02-07},
	file = {Joe Duffy - The Error Model:/home/girgias/Zotero/storage/8UGJPHI3/the-error-model.html:text/html},
}

@inproceedings{baniassad_reframing_2021,
	location = {New York, {NY}, {USA}},
	title = {Reframing the Liskov substitution principle through the lens of testing},
	isbn = {978-1-4503-9089-7},
	url = {https://doi.org/10.1145/3484272.3484965},
	doi = {10.1145/3484272.3484965},
	series = {{SPLASH}-E 2021},
	abstract = {In this essay, we explore a new pedagogical framing ofway of pedagogically and teaching the Liskov Substitution Principle ({LSP}). In addition to, or perhaps even in place of, teaching the specifics of the rule itself, we advocatepropose teaching an operationalised version of the rule: that a subtype must pass its supertype’s black box tests for each of its overriding methods. We leverage the fact that black box tests should be written to capture conformance to a specification without overfitting or checking implementation internalsdetails (as would be checked by glass box tests). A type that violates the rules of substitutability will also fail a potential corresponding black box test for the supertype. Additionally, we argue that the over-strict nature of the classical {LSP} Postcondition Rule (which has been improved in subsequent work) can be a source of confusion for both instructors and for students learning this crucial concept for the first time. Pleasingly, many of the technical subtleties of this nuanced but important concept drop out naturally when thinking of substitutability via black box tests. Thus we put forward We propose that this test-oriented means of teaching substitutability is a valuable alternative to the classical sense of checking the {LSP}, with the benefit of being intuitively accessible to students.},
	pages = {49--58},
	booktitle = {Proceedings of the 2021 {ACM} {SIGPLAN} International Symposium on {SPLASH}-E},
	publisher = {Association for Computing Machinery},
	author = {Baniassad, Elisa and Summers, Alexander J.},
	urldate = {2025-04-20},
	date = {2021-10-17},
}

@online{wayne_better_2023,
	title = {A better explanation of the Liskov Substitution Principle},
	url = {https://www.hillelwayne.com/post/lsp/},
	abstract = {Short version: If X inherits from Y, then X should pass all of Y’s black box tests.
I first encountered this idea at {SPLASH} 2021.
The longer explanation A bit of background In A Behavioral Notion of Subtyping Liskov originally defined subtyping in inherited objects as follows:
 Subtype Requirement: Let P(x) be a property provable about objects x of type T. Then P(y) should be true for objects y of type S where S is a subtype of T.},
	titleaddon = {Hillel Wayne},
	type = {Blog},
	author = {Wayne, Hillel},
	urldate = {2025-04-20},
	date = {2023-11-07},
	langid = {english},
	note = {Section: Post},
	file = {Snapshot:/home/girgias/Zotero/storage/MXDEJCCE/lsp.html:text/html},
}

@book{stroustrup_c_1997,
	location = {Reading, Mass},
	edition = {3rd ed},
	title = {The C++ programming language},
	isbn = {978-0-201-88954-3},
	publisher = {Addison-Wesley},
	author = {Stroustrup, Bjarne},
	date = {1997},
}

@incollection{stroustrup_use_1997,
	location = {Reading, Mass},
	edition = {3rd ed},
	title = {Use of Protected Members},
	isbn = {978-0-201-88954-3},
	pages = {405},
	booktitle = {The C++ programming language},
	publisher = {Addison-Wesley},
	author = {Stroustrup, Bjarne},
	date = {1997},
}

@article{dijkstra_humble_1972,
	title = {The humble programmer},
	volume = {15},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/355604.361591},
	doi = {10.1145/355604.361591},
	pages = {859--866},
	number = {10},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Dijkstra, Edsger W.},
	urldate = {2025-04-20},
	date = {1972-10},
	langid = {english},
	file = {PDF:/home/girgias/Zotero/storage/ZF6GL2G5/Dijkstra - 1972 - The humble programmer.pdf:application/pdf},
}

@online{kocsis_php_2020,
	title = {{PHP} {RFC}: Mixed Type v2},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/mixed_type_v2},
	shorttitle = {Mixed Type v2},
	abstract = {With the addition of scalar types in {PHP} 7, nullables in 7.1, object in 7.2, and lastly, union types in 8.0, people writing {PHP} code can explicitly declare type information for most function parameters, function returns, as well as class properties.

However, {PHP} has not always supported types, and most probably it will always allow to omit type information. But this leads to the problem that its meaning is ambiguous when type information is missing:},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Kocsis, Máté and Ackroyd, Dan},
	urldate = {2025-04-20},
	date = {2020-03-23},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:mixed_type_v2:/home/girgias/Zotero/storage/THBJV2VL/mixed_type_v2.html:text/html},
}

@online{popov_php_2019,
	title = {{PHP} {RFC}: Union Types 2.0},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/union_types_v2},
	shorttitle = {Union Types 2.0},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Popov, Nikita},
	urldate = {2025-04-20},
	date = {2019-09-02},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:union_types_v2:/home/girgias/Zotero/storage/BTC9TPXJ/union_types_v2.html:text/html},
}

@online{brown_php_2021,
	title = {{PHP} {RFC}: noreturn type},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/noreturn_type},
	shorttitle = {noreturn type},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Brown, Matt and Mirtes, Ondřej},
	urldate = {2025-04-20},
	date = {2021-03-10},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:noreturn_type:/home/girgias/Zotero/storage/U2T9IY6B/noreturn_type.html:text/html},
}

@online{banyard_php_2021,
	title = {{PHP} {RFC}: Pure intersection types},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/pure-intersection-types},
	shorttitle = {Pure intersection types},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2025-04-20},
	date = {2021-03-23},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:pure-intersection-types:/home/girgias/Zotero/storage/QBLCZ9GX/pure-intersection-types.html:text/html},
}

@online{banyard_php_2022-1,
	title = {{PHP} {RFC}: Add true type},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/true-type},
	shorttitle = {Add true type},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2025-04-20},
	date = {2022-04-07},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:true-type:/home/girgias/Zotero/storage/RWHMPIRQ/true-type.html:text/html},
}

@online{banyard_php_2021-1,
	title = {{PHP} {RFC}: Disjunctive Normal Form Types},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/dnf_types},
	shorttitle = {Disjunctive Normal Form Types},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter and Garfield, Larry},
	urldate = {2025-04-20},
	date = {2021-11-04},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:dnf_types:/home/girgias/Zotero/storage/TZ4KZTD6/dnf_types.html:text/html},
}

@online{banyard_php_2022-2,
	title = {{PHP} {RFC}: Allow null and false as stand-alone types},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/null-false-standalone-types},
	shorttitle = {Allow null and false as stand-alone types},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Banyard, George Peter},
	urldate = {2025-04-20},
	date = {2022-02-20},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:null-false-standalone-types:/home/girgias/Zotero/storage/EVXEPLPN/null-false-standalone-types.html:text/html},
}

@online{weisstein_disjunctive_nodate,
	title = {Disjunctive Normal Form},
	rights = {Copyright 1999-2025 Wolfram Research, Inc.  See https://mathworld.wolfram.com/about/terms.html for a full terms of use statement.},
	url = {https://mathworld.wolfram.com/DisjunctiveNormalForm.html},
	abstract = {A statement is in disjunctive normal form if it is a disjunction (sequence of {ORs}) consisting of one or more disjuncts, each of which is a conjunction ({AND}) of one or more literals (i.e., statement letters and negations of statement letters; Mendelson 1997, p. 30). Disjunctive normal form is not unique. The Wolfram Language command {LogicalExpand}[expr] gives disjunctive normal form (with some contractions, i.e., {LogicalExpand} attempts to shorten output with heuristic simplification). Examples...},
	type = {Text},
	author = {Weisstein, Eric W.},
	urldate = {2025-04-20},
	langid = {english},
	note = {Publisher: Wolfram Research, Inc.},
	file = {Snapshot:/home/girgias/Zotero/storage/P35MP6LZ/DisjunctiveNormalForm.html:text/html},
}

@inreference{noauthor_type_2025,
	title = {Type system},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Type_system&oldid=1286041555},
	abstract = {In computer programming, a type system is a logical system comprising a set of rules that assigns a property called a type (for example, integer, floating point, string) to every term (a word, phrase, or other set of symbols). Usually the terms are various language constructs of a computer program, such as variables, expressions, functions, or modules. A type system dictates the operations that can be performed on a term. For variables, the type system determines the allowed values of that term. 
Type systems formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other data types, such as "string", "array of float", "function returning boolean".
Type systems are often specified as part of programming languages and built into interpreters and compilers, although the type system of a language can be extended by optional tools that perform added checks using the language's original type syntax and grammar. 
The main purpose of a type system in a programming language is to reduce possibilities for bugs in computer programs due to type errors. The given type system in question determines what constitutes a type error, but in general, the aim is to prevent operations expecting a certain kind of value from being used with values of which that operation does not make sense (validity errors). 
Type systems allow defining interfaces between different parts of a computer program, and then checking that the parts have been connected in a consistent way. This checking can happen statically (at compile time), dynamically (at run time), or as a combination of both. 
Type systems have other purposes as well, such as expressing business rules, enabling certain compiler optimizations, allowing for multiple dispatch, and providing a form of documentation.},
	booktitle = {Wikipedia},
	urldate = {2025-04-20},
	date = {2025-04-17},
	langid = {english},
	note = {Page Version {ID}: 1286041555},
	file = {Snapshot:/home/girgias/Zotero/storage/XDADG23Y/Type_system.html:text/html},
}

@online{brzuchalski_php_2016,
	title = {{PHP} {RFC}: Object typehint},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/object-typehint},
	shorttitle = {Object typehint},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Brzuchalski, Michał and Ackroyd, Dan},
	urldate = {2025-04-20},
	date = {2016-08-12},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:object-typehint:/home/girgias/Zotero/storage/LZ9CI5Y4/object-typehint.html:text/html},
}

@online{popov_php_2020,
	title = {{PHP} {RFC}: Static return type},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/static_return_type},
	shorttitle = {Static return type},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Popov, Nikita},
	urldate = {2025-04-20},
	date = {2020-01-08},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:static_return_type:/home/girgias/Zotero/storage/PGKAPMC3/static_return_type.html:text/html},
}

@online{popov_php_2021,
	title = {{PHP} {RFC}: First-class callable syntax},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/first_class_callable_syntax},
	shorttitle = {First-class callable syntax},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Popov, Nikita and Watkins, Joe},
	urldate = {2025-04-20},
	date = {2021-05-20},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:first_class_callable_syntax:/home/girgias/Zotero/storage/JQ2ISDIU/first_class_callable_syntax.html:text/html},
}

@online{noauthor_convert_nodate,
	title = {Convert iterable into an internal alias for Traversable{\textbar}array by Girgias · Pull Request \#7309 · php/php-src},
	url = {https://github.com/php/php-src/pull/7309},
	urldate = {2025-04-20},
	file = {Convert iterable into an internal alias for Traversable|array by Girgias · Pull Request #7309 · php/php-src:/home/girgias/Zotero/storage/4WZ7EMAW/7309.html:text/html},
}

@online{tovilo_php_2020,
	title = {{PHP} {RFC}: Enumerations},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/enumerations},
	shorttitle = {Enumerations},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Tovilo, Ilija and Garfield, Larry},
	urldate = {2025-04-20},
	date = {2020-12-04},
	keywords = {{PHP} {RFC}},
	file = {PHP\: rfc\:enumerations:/home/girgias/Zotero/storage/Y489LDFQ/enumerations.html:text/html},
}

@online{popov_php_2020-1,
	title = {{PHP} {RFC}: Deprecate passing null to non-nullable arguments of internal functions},
	rights = {Attribution-{NonCommercial}-{ShareAlike} 4.0 International ({CC} {BY}-{NC}-{SA} 4.0)},
	url = {https://wiki.php.net/rfc/deprecate_null_to_scalar_internal_arg},
	shorttitle = {Deprecate passing null to non-nullable arguments of internal functions},
	titleaddon = {{PHP}: Request for Comments},
	type = {Wiki},
	author = {Popov, Nikita},
	urldate = {2025-04-20},
	date = {2020-12-01},
	file = {PHP\: rfc\:deprecate_null_to_scalar_internal_arg:/home/girgias/Zotero/storage/JVN4P2AV/deprecate_null_to_scalar_internal_arg.html:text/html},
}

@online{le_blanc_state_2024,
	title = {State of Generics and Collections},
	url = {https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections/},
	abstract = {The {PHP} Foundation — Supporting, Advancing, and Developing the {PHP} Language},
	titleaddon = {The {PHP} Foundation},
	type = {Company Website},
	author = {Le Blanc, Arnaud and Rethans, Derick and Garfield, Larry},
	urldate = {2025-04-20},
	date = {2024-08-19},
	langid = {english},
	file = {Snapshot:/home/girgias/Zotero/storage/2CYC2F7Q/state-of-generics-and-collections.html:text/html},
}

@inreference{noauthor_subtyping_2024,
	title = {Subtyping},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Subtyping&oldid=1260413110},
	abstract = {In programming language theory, subtyping (also called subtype polymorphism or inclusion polymorphism) is a form of type polymorphism. A subtype is a datatype that is related to another datatype (the supertype) by some notion of substitutability, meaning that program elements (typically subroutines or functions), written to operate on elements of the supertype, can also operate on elements of the subtype. 
If S is a subtype of T, the subtyping relation (written as S {\textless}: T,  S ⊑ T, or  S ≤: T ) means that any term of type S can safely be used in any context where a term of type T is expected. The precise semantics of subtyping here crucially depends on the particulars of how "safely be used" and "any context" are defined by a given type formalism or programming language. The type system of a programming language essentially defines its own subtyping relation, which may well be trivial, should the language support no (or very little) conversion mechanisms.
Due to the subtyping relation, a term may belong to more than one type. Subtyping is therefore a form of type polymorphism. In object-oriented programming the term 'polymorphism' is commonly used to refer solely to this subtype polymorphism, while the techniques of parametric polymorphism would be considered generic programming.
Functional programming languages often allow the subtyping of records. Consequently, simply typed lambda calculus extended with record types is perhaps the simplest theoretical setting in which a useful notion of subtyping may be defined and studied. Because the resulting calculus allows terms to have more than one type, it is no longer a "simple" type theory. Since functional programming languages, by definition, support function literals, which can also be stored in records, records types with subtyping provide some of the features of object-oriented programming. Typically, functional programming languages also provide some, usually restricted, form of parametric polymorphism. In a theoretical setting, it is desirable to study the interaction of the two features; a common theoretical setting is system F{\textless}:. Various calculi that attempt to capture the theoretical properties of object-oriented programming may be derived from system F{\textless}:.
The concept of subtyping is related to the linguistic notions of hyponymy and holonymy. It is also related to the concept of bounded quantification in mathematical logic (see Order-sorted logic). Subtyping should not be confused with the notion of (class or object) inheritance from object-oriented languages; subtyping is a relation between types (interfaces in object-oriented parlance) whereas inheritance is a relation between implementations stemming from a language feature that allows new objects to be created from existing ones. In a number of object-oriented languages, subtyping is called interface inheritance, with inheritance referred to as implementation inheritance.},
	booktitle = {Wikipedia},
	urldate = {2025-04-20},
	date = {2024-11-30},
	langid = {english},
	note = {Page Version {ID}: 1260413110},
	file = {Snapshot:/home/girgias/Zotero/storage/P8BCL262/Subtyping.html:text/html},
}